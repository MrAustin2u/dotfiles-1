priority 1

global !p

# Converts underscore_syntax to CamelCase.
def underscore_to_camelcase(string):
		return ''.join(map(lambda s: s.capitalize(), string.split('_')))
# Converts a `path` to an Elixir module name. The path is assumed to be without
# finale extension. Example: foo/bar/baz_bong => Foo.Bar.BazBong
def convert_to_module(path):
		components = path.split('/')
		aliases    = map(underscore_to_camelcase, components)
		return '.'.join(aliases)
# Returns the proper Elixir module name given a `path` (assumed to be in
# `lib/`).
def module_from_path(path):
		path       = re.sub(r'^(.*?)lib\/', '', path)
		path       = re.sub(r'^(.*?)test\/', '', path)
		path, _ext = os.path.splitext(path)
		return convert_to_module(path)
# Returns the a proper Elixir module name given a `path` (assumed to be a test
# inside `test/`).
def module_from_test_path(path):
		path = re.sub(r'^(.*?)test\/', '', path)
		path = re.sub(r'^(.*?)lib\/', '', path)
		path = re.sub(r'_test\.exs$', '', path)
		return convert_to_module(path)
# Returns the name of the principal context.
def app_context(path):
		path = re.sub(r'^(.*?)test\/', '', path)
		path = re.sub(r'^(.*?)lib\/', '', path)
		components = path.split('/')

		return underscore_to_camelcase(components[0])
endglobal


snippet defm "Regular module definition" b
defmodule $1 do
	$2
end
endsnippet

snippet defmod "Automatically-named-module definition" b
defmodule `!p snip.rv = module_from_path(path)` do
	$1
end
endsnippet

snippet deft "Regular test module definition" b
defmodule $1Test do
	use ExUnit.Case, async: true
	alias `!p snip.rv = t[1]`

	$2
end
endsnippet

snippet deftest "Automatically-named-test-module definition" b
defmodule `!p snip.rv = module_from_test_path(path)`Test do
	use ExUnit.Case, async: true

	$2
end
endsnippet

snippet deflvtest "LiveView named-test-module definition" b
defmodule `!p snip.rv = module_from_test_path(path)`Test do
	use `!p snip.rv = app_context(path)`.ConnCase, async: true

	import Phoenix.LiveViewTest

	$2
end
endsnippet

snippet t "Single test macro" b
test "$1" do
	$2
end
endsnippet

snippet tconn "Single test macro" b
test "$1", %{conn: conn} do
	$2
end
endsnippet

snippet ins "IO.inspect"
IO.inspect(${0})
endsnippet

snippet def "defines a new function with a multiline block" !b
def ${1:name}(${2:params}) do
  $0
end
endsnippet

snippet defl "defines a new function" !b
def ${1:name}(${2:params}), do: $0
endsnippet

snippet defp "defines a private method with a multiline block" !b
defp ${1:name}(${2:params}) do
  $0
end
endsnippet

snippet defpl "defines a new private function" !b
defp ${1:name}(${2:params}), do: $0
endsnippet

snippet defm "defines a macro" !b
defmacro ${1:name}(${2:params}) do
  $0
end
endsnippet

snippet if "add an if block" !b
if ${1:condition} do
  $0
end
endsnippet

snippet ife "add an if-else block" !b
if ${1:condition} do
  $2
else
  $0
end
endsnippet

snippet fn "insert an anonymous function" !i
fn(${1:args}) -> ${0} end
endsnippet

snippet & "insert an anonymous function short syntax" !i
&($1)$0
endsnippet

snippet doc "insert a function documentation block" !b
@doc """
${0}
"""
endsnippet

snippet mdoc "insert a module documentation block" !b
@moduledoc """
${0}
"""
endsnippet

snippet # "insert a string interpolation" !i
#{${1}}$0
endsnippet

snippet % "Insert a map with symbols as keys" !i
%{${1:key}: ${2:value}}$0
endsnippet

snippet %b "Insert a map with binaries as keys" !i
%{"${1:key}" => ${2:value}}$0
endsnippet

snippet ok "Insert ok tuple" !i
{:ok, ${1:value}}$0
endsnippet

snippet err "Insert error tuple" !i
{:error, ${1:value}}$0
endsnippet

